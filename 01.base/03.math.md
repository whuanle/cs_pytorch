# 1.3 数学基础



### 推荐书籍

大家都知道学习 Pytorch 或 AI 需要一定的数学基础，当然也不需要太高，只需要掌握一些基础知识和求解方法，常见需要的数学基础有线性代数、微积分、概率论等，由于高等数学课程里面同时包含了线性代数和微积分的知识，因此读者只需要学习高等数学、概率论两门课程即可。数学不用看得太深，这样太花时间了，能理解意思就行。

 

首先推荐以下两本书，无论是否已经忘记了初高中数学知识，对于数学基础薄弱的读者来说，都可以看。

* 《普林斯顿微积分读本》

* 《普林斯顿概率论读本》



国内的书主要是一些教材，学习难度会大一些，不过完整看完可以提升数学水平，例如同济大学出版的《高等数学》上下册、《概率论与数理统计》，不过国内的这些教材主要为了刷题解题、考研考试，可能不太适合读者，而且学习起来的时间也太长了。



接着是推荐《深度学习中的数学》，作者是涌井良幸和涌井贞美，对于入门的读者来说上手难度也大一些，不那么容易看得进去，读者可以在看完本文之后再去阅读这本经典书，相信会更加容易读懂。



另外，千万不要用微信读书这些工具看数学书，排版乱七八糟的，数学公式是各种抠图，数学符号也是用图片拼凑的，再比如公式里面中文英文符号都不分。

建议直接买实体书，容易深度思考，数学要多答题解题才行。就算买来吃灰，放在书架也可以装逼呀。买吧。



本文虽然不要求读者数学基础，但是还是需要知道一些数学符号的，例如求和∑ 、集合交并∩∪等，这些在本文中不会再赘述，读者不理解的时候需要自行搜索资料。



## 基础知识

### 标量、向量、矩阵

笔者只能给出大体的概念，至于数学上的具体定义，这里就不展开了。

标量(scalar)：只有大小没有方向的数值，例如体重、身高。

向量(vector)：既有大小也有方向的数值，可以用行或列来表示。

矩阵(matrix)：由多行多列的向量组成。

张量(Tensor)：在 Pytorch 中，torch.Tensor 类型数据结构就是张量，结构跟数组或矩阵相似。



- Tensor：是PyTorch中的基本数据类型，可以理解为多维数组。 Tensor可以用来表示数据集、模型参数和模型输出等。
- Scalar：是一个特殊类型的Tensor，只有一维。 Scalar用来表示标量值，如学习率、损失值等。
- Vector：是一个特殊类型的Tensor，有一维或两维。 Vector用来表示向量值，如梯度、特征值等。
- Matrix：是一个特殊类型的Tensor，有两维。 Matrix用来表示矩阵值，如权重矩阵、输出矩阵等。



比如说 1.0、2 这些都是标量，在各种编程语言中都以基础数据类型提供了支持，例如 C# 的基元类型。



下面将标量转换为 torch.Tensor 类型。

```csharp
var x = torch.tensor(1.0);
var y = torch.tensor(2);

x.print_csharp();
y.print_csharp();
```

```bash
[], type = Float64, device = cpu, value = 1
[], type = Int32, device = cpu, value = 2
```



将数组转换为 torch.Tensor 类型：

```csharp
var data = new int[,]{{1, 2}, { 3, 4}};
var x_data = torch.tensor(data);

x_data.print_csharp();
```



由于上一章已经讲解了很多数组的创建方式，因此这里不再赘述。



### Pytorch 的一些数学函数

Pytorch 通过 torch.Tensor 表示各种数据类型，torch.Tensor 提供超过 100 多种的张量操作，例如算术运算、线性代数、矩阵操作、采样等。

由于篇幅有限，这里就不单独给出，读者请自行参考以下资料：

https://pytorch.org/docs/stable/torch.html

https://pytorch.ac.cn/docs/stable/torch.html





## 线性代数



### 向量

#### 向量的概念

在研究力学、物理学等工程应用领域中会碰到两类的量，一类完全由**数值的大小**决定，例如温度、时间、面积、体积、密度、质量等，称为**数量**或**标量**，另一类的量，**只知道数值的大小还不能完全确定所描述量**，例如加速度、速度等，这些量除了大小还有方向，称为向量。

在空间中以 A 为起点 、B 为终点的线段被称为被称为有向线段，其既有大小也有方向，使用 $\overrightarrow{AB} $ 表示，如果不强调方向，也可以使用 $\alpha $ 等进行简记。

![image-20241108071154361](images/image-20241108071154361.png)

A、B 之间的距离称为向量的模，使用 | $\overrightarrow{AB} $ | 或 | $\overrightarrow{BA} $ | 或 | $\alpha $ | 表示。

平面中的向量，其距离公式是：

$$
| \overrightarrow{AB} | = \sqrt{(x_{2}-x_{1})^{2} + (y_{2}-y_{1})^2}
$$
其实原理也很简单，根据勾股定理，AB 的平方等于两个直角边长平方之和，所以：
$$
| \overrightarrow{AB} | ^2 = (x_{2}-x_{1})^{2} + (y_{2}-y_{1})^2
$$
![image-20241108212312023](images/image-20241108212312023.png)

去平方就是：
$$
| \overrightarrow{AB} | = \sqrt{(x_{2}-x_{1})^{2} + (y_{2}-y_{1})^2}
$$




如下图所示，其两点间的距离：

$$
 | \overrightarrow{AB}  | = \sqrt{(4-1)^{2} + (4-1)^2} = \sqrt{18} = 3\sqrt{2} = 4.242640687119285
$$




![image-20241108071828663](images/image-20241108071828663.png)



使用 C# 计算向量的模，结果如下

```csharp
var A = torch.from_array(new[] { 1.0, 1.0 });
var B = torch.from_array(new[] { 4.0, 4.0 });
var a = B - A;

var norm = torch.norm(a);
norm.print_csharp();
```

```
[], type = Float64, device = cpu, value = 4.2426
```

> 注意，计算向量的模只能使用浮点型数据，不能使用 int、long 这些整型。



同理，对于空间中的两点 $A(x_{1},y_{1},z_{1})$、$B(x_{2},y_{2},z_{2})$ ，距离公式是：

$$
| \overrightarrow{AB} | = \sqrt{(x_{2}-x_{1})^{2} + (y_{2}-y_{1})^2 + (z_{2}-z_{1})^2} 
$$




#### 向量的加减乘除法

向量的加法很简单，坐标相加即可。

如图所示，A(1,1)、B(3,5)、C(6,4)。

$\overrightarrow{AB} (2,4) $、$\overrightarrow{BC} (3,-1) $、$\overrightarrow{AC} (5,3) $

根据数学上向量的加法可知，$\overrightarrow{AB} $ + $\overrightarrow{BC} $ = $\overrightarrow{AC} $

```csharp
var B = torch.from_array(new[] { 2.0, 4.0 });
var A = torch.from_array(new[] { 3.0, -1.0 });
var a = A + B;

a.print_csharp();
```

```
[2], type = Float64, device = cpu, value = double [] {5, 3}
```



![image-20241108205142069](images/image-20241108205142069.png)



同理，在 Pytorch 中，向量减法也是两个 torch.Tensor 类型相减即可。

推广到三维空间，计算方法也是一样的。

```csharp
var B = torch.from_array(new[] { 2.0, 3.0, 4.0 });
var A = torch.from_array(new[] { 3.0, 4.0, 5.0 });
var a = B - A;

a.print_csharp();
```

```
[3], type = Float64, device = cpu, value = double [] {-1, -1, -1}
```



另外，向量乘以或除以一个标量，直接运算即可，如 $ \overrightarrow{AB} (2,4) $，则 3 * $ \overrightarrow{AB} (2,4) $ = (6,12)。 



#### 向量的投影

如图所示， $\overrightarrow{AB} (2,4) $ 是平面上的向量，如果我们要计算向量在 x、y 上的投影是很简单的，例如在 x 轴上的投影是 2，因为 A 点的 x 坐标是 1，B 点的 x 坐标是 3，所以 3 - 1 = 2 为  $\overrightarrow{AB} (2,4) $ 在 x 轴上的投影，5 - 1 = 4 是在 y 轴上的投影。

![image-20241108211302187](images/image-20241108211302187.png)



在数学上使用 $Projx(u)$ 表示向量 u 在 x 上的投影，同理 $Projy(u)$ 是 u 在 y 上的投影。

如果使用三角函数，我们可以这样计算向量在各个轴上的投影。
$$
Projx(u) = |\overrightarrow{AB}| \cos \alpha = |\overrightarrow{AC}|
$$

$$
Projy(u) = |\overrightarrow{AB}| \sin \alpha = |\overrightarrow{BC}|
$$



AC、BC 长度是 4，根据勾股定理得出 AB 长度是 $4\sqrt{2} $，由于 $cos \frac{\pi }{2} = \frac{\sqrt{2}} {2}$ ，所以 $Projx(u) = 4$。

![image-20241108212445350](images/image-20241108212445350.png)



那么在平面中，我们已知向量的坐标，求向量与 x 、y 轴的夹角，可以这样求。
$$
\cos \alpha  = \frac{x}{|v|}
$$

$$
\sin \alpha  = \frac{y}{|v|}
$$



例如上图中  $\overrightarrow{AB} (4,4) $，x 和 y 都是 4，其中  $|v| = 4\sqrt{2}$，所以 $\cos \alpha  = \frac{4}{4\sqrt{2}} = \frac{\sqrt{2}}{2}$ 



从 x、y 轴推广到平面中任意两个向量，$\alpha$、$\beta$，其夹角为：
$$
\cos \varphi = \frac{\alpha \cdot \beta}{|\alpha|\cdot|\beta|}
$$
继续按下图所示，计算 $\overrightarrow{AB}$、$\overrightarrow{AC}$ 之间的夹角，很明显，我们按经验直接可以得出夹角 $\varphi$ 是 45° 。

![image-20241108221035111](images/image-20241108221035111.png)



但是如果我们要通过投影方式计算出来，则根据 $ \frac{\alpha \cdot \beta}{|\alpha|\cdot|\beta|} $ ，是 C# 计算如下。

```csharp
var AB = torch.from_array(new[] { 4.0, 4.0 });
var AC = torch.from_array(new[] { 4.0, 0.0 });

// 点积
var dot = torch.dot(AB, AC);

// 求每个向量的模
var ab = torch.norm(AB);
var ac = torch.norm(AC);

// 求出 cosφ 的值
var cos = dot / (ab * ac);
cos.print_csharp();

// 使用 torch.acos 计算夹角 (以弧度为单位)
var theta = torch.acos(cos);

// 将弧度转换为角度
var theta_degrees = torch.rad2deg(theta);
theta_degrees.print_csharp();
```

```
[], type = Float64, device = cpu, value = 0.70711
[], type = Float64, device = cpu, value = 45
```

![image-20241108221229577](images/image-20241108221229577.png)





对于立体空间中，求取两个向量的夹角公式：



![image-20240910121926988](./images/image-20240910121926988.png)



这里就不再赘述。



#### 向量的点积

**点积即向量的数量积，点积、数量积、内积，都是同一个东西。**

两个向量的数量积是标量，即一个数值，而向量积是不同的东西，这里只说明数量积。

数量积称为两个向量的数乘，而向量积才是两个向量的乘法。

向量的数乘公式如下：
$$
a\cdot b=\displaystyle\sum_{i=1}^{n} a_{i} b_{i}=a_{1} b_{1}+a_{2} b_{2}+...+a_{n} b_{n}
$$
例如 $\overrightarrow{AB} (2,4) $、$\overrightarrow{BC} (3,-1) $ 两个向量，如下图所示。



![image-20241108205142069](images/image-20241108205142069.png)

计算其点积如下：

```csharp
var B = torch.from_array(new[] { 2.0, 4.0 });
var A = torch.from_array(new[] { 3.0, -1.0 });

var dot = torch.dot(A, B);

dot.print_csharp();
```

```
[], type = Float64, device = cpu, value = 2
```





#### 向量积

在坐标轴上，我们默认间距都是 1，此时 x、y、z 上的单位向量都是 1，在数学中，我们往往会有很多未知数，此时我们使用 i、j、k 表示 x、y、z 轴上的单位向量，**在数学和物理中，单位向量通常用于表示方向而不关心其大小**。不理解这句话也没关系，忽略。



在不关心向量大小的情况下，我们使用单位向量可以这样表示两个向量：
$$
a = x_{1}i+y_{1}j+z_{1}k = (x_{1}, y_{1}, z_{1})
$$

$$
b = x_{2}i+y_{2}j+z_{2}k = (x_{2}, y_{2}, z_{2})
$$





如下所示，我们并不关心向量的真正大小，我们只关心其方向，在 x 轴上的每个格的长度为 i，y 轴是 j，z 轴是 k。

![image-20241108223336564](images/image-20241108223336564.png)

现在我们来求解一个问题，在空间中找到跟 $\overrightarrow{AB} $、$\overrightarrow{BC} $  同时垂直的向量，很明显，这样的向量不止一个，有无数个，所以我们这个时候要了解什么是法向量和单位向量。

法向量是一个与平面垂直的向量（这里不涉及曲面、曲线这些），要找出法向量也很简单，有两种方法，一种是坐标表示：
$$
a \times b =
\begin{vmatrix}
  &i  &j &k  \\
  &x_{1} &y_{1} &z_{1} \\
  &x_{2} &y_{2} &z_{2}
\end{vmatrix} = (y_{1}z_{2}-z_{1}y_{2})i - (x_{1}z_{2}-z_{1}x_{2})j + (x_{1}y_{2}-y_{1}x_{2})k
$$


这样记起来有些困难，我们可以这样看，容易记得。


$$
a \times b =
\begin{vmatrix}
  &i  &j &k  \\
  &x_{1} &y_{1} &z_{1} \\
  &x_{2} &y_{2} &z_{2}
\end{vmatrix} = (y_{1}z_{2}-z_{1}y_{2})i + (z_{1}x_{2}-x_{1}z_{2})j + (x_{1}y_{2}-y_{1}x_{2})k
$$


那么法向量 $n$ 的  $x = (y_{1}{z2} -z_{1}y_{2})$ ，y、z 轴同理，就不给出了，x、y、z 分别就是 i、j、k 前面的一块符号公式。



例题如下。

求与 $a = 3i - 2j + 4k$ ，$b = i + j - 2k$ 都垂直的法向量 。

首先提取 a 向量坐标表示是 (3,-2,4)，b 向量的坐标表示是 (1,1,-2)。

则：
$$
a \times b =
\begin{vmatrix}
  &i  &j &k  \\
  &3 &-2 &4 \\
  &1 &1 &-2
\end{vmatrix} = (4-4)i + (4-(-6))j + (3-(-2))k = 10j + 5k
$$

所以法向量 $n(0,10,5)$

这就是通过向量积求得与两个向量都垂直的法向量的方法。



你甚至可以使用 C# 手撸这个算法出来：

```csharp
var A = torch.tensor(new double[] { 3.0, -2, 4 });

var B = torch.tensor(new double[] { 1.0, 1.0, -2.0 });
var cross = Cross(A, B);
cross.print();

static Tensor Cross(Tensor A, Tensor B)
{
    if (A.size(0) != 3 || B.size(0) != 3)
    {
        throw new ArgumentException("Both input tensors must be 3-dimensional.");
    }

    var a1 = A[0];
    var a2 = A[1];
    var a3 = A[2];
    var b1 = B[0];
    var b2 = B[1];
    var b3 = B[2];

    var i = a2 * b3 - a3 * b2;
    var j = a3 * b1 - a1 * b3;
    var k = a1 * b2 - a2 * b1;

    return torch.tensor(new double[] { i.ToDouble(), -j.ToDouble(), k.ToDouble() });
}
```

```
[3], type = Float64, device = cpu 0 -10 5
```



由于当前笔者所用的 C# 版本的 cross 函数不对劲，我们也可以利用内核函数直接扩展一个接口出来。

```csharp
public static class MyTorch
{
    [DllImport("LibTorchSharp")]
    public static extern IntPtr THSLinalg_cross(IntPtr input, IntPtr other, long dim);

    public static Tensor cross(Tensor input, Tensor other, long dim = -1)
    {
        var res = THSLinalg_cross(input.Handle, other.Handle, dim);
        if (res == IntPtr.Zero) { torch.CheckForErrors(); }
        return torch.Tensor.UnsafeCreateTensor(res);
    }
}
```

```csharp
var A = torch.tensor(new double[] { 3.0, -2, 4 });

var B = torch.tensor(new double[] { 1.0, 1.0, -2.0 });

var cross = MyTorch.cross(A, B);
cross.print_csharp();
```

```
[3], type = Float64, device = cpu, value = double [] {0, 10, 5}
```



当前笔者所用版本 other 参数是 Scalar 而不是 Tensor，这里应该是个 bug，最新 main 分支已经修复，但是还没有发布。

![image-20241109024627974](images/image-20241109024627974.png)



另外，还有一种通过夹角求得法向量的方法。
$$
a \times b = |a| \cdot |b| \sin\alpha
$$
一般来说，对于空间求解问题，我们往往是可以计算向量积的，然后通过向量积得出 $|a| \cdot |b| \sin\alpha$ 的结果，而不是通过 $|a| \cdot |b| \sin\alpha$ 求出 $a \times b$ 。

关于此条公式，这里暂时不深入。



#### 平面和直线问题

在本小节节中，我们将学习如何求解空间中的直线和平面问题。

在空间中的平面，可以使用一般式方程表达：
$$
v = Ax + By + Cz + D
$$
其中 A、B、C 是法向量的坐标，即 $n = \{A,B,C\}$。



首先，空间中的直线有三种表示方法，分别是对称式方程、参数式方程、截距式方程。



**直线的对称式方程**

给定空间中的一点 $P_{0}(x_{0},y_{0},z_{0})$ 有一条直线 L 穿过 $p_{0}$ 点，以及和非零向量 $v=\{l,m,n\}$ 平行。

![image-20241109150817967](images/image-20241109150817967.png)



直线上任意一点和 $p_{0}$ 的向量都和 $v$ 平行，$\overrightarrow{P_{0}P} =\{x - x_{0},y - y_{0}, z - z_{0}\}$，所以其因为其对应的坐标成比例，所以其截距式方程为：
$$
\frac{x-x_{0}}{l} = \frac{y-y_{0}}{m} =\frac{z-z_{0}}{n}
$$
**直线的参数式方程**

因为：
$$
\frac{x-x_{0}}{l} = \frac{y-y_{0}}{m} =\frac{z-z_{0}}{n} = t
$$


所以：
$$
\begin{cases}x = x_{0} + lt
 \\y = y_{0} + mt
 \\z = z_{0} + nt

\end{cases}
$$


这便是直线的参数式方程。



**直线的一般式方程**

空间中的直线可以看作是两个平面之间的交线，所以直线由两个平面的一般式方程给出：
$$
\begin{cases}v_{1} = A_{1}x + B_{1}y + C_{1}z + D_{1}
 \\ v_{2} = A_{2}x + B_{2}y + C_{2}z + D_{2}

\end{cases}
$$
这些公式在计算以下场景问题时很有帮助，不过这里不再赘述。



① 空间中任意一点到平面的距离。

② 直线和平面之间的夹角。

③ 平面之间的夹角。





### 矩阵

如下图所示，A 是一个矩阵，具有多行多列。

![image-20240910115046782](./images/image-20240910115046782.png)

在 C# 中，矩阵属于二维数组，即 $m*n$ ，例如要创建一个 $3*3$ 的矩阵，可以这样表示：

```csharp
var A = torch.tensor(new double[,]
{
    { 3.0, -2.0, 4.0 },
    { 3.0, -2.0, 4.0 },
    { 3.0, -2.0, 4.0 }
});

A.print_csharp();
```



使用 `.T` 将矩阵的行和列倒过来：

```csharp
var A = torch.tensor(new double[,]
{
    { 3.0, -2.0, 4.0 }
});

A.T.print_csharp();
```

生成的是：

```
{
	{3.0},
	{-2.0},
	{4.0}
}
```

如图所示：

![image-20241109154450656](images/image-20241109154450656.png)





矩阵的加减法很简单，就是相同位置的数组加减。

```csharp
var A = torch.tensor(new double[,]
{
    { 1.0, 2.0, 4.0 },
    { 1.0, 2.0, 4.0 },
    { 1.0, 2.0, 4.0 }
});

var B = torch.tensor(new double[,]
{
    { 1.0, 1.0, 2.0 },
    { 1.0, 1.0, 2.0 },
    { 1.0, 1.0, 2.0 }
});

(A+B).print_csharp();
```

结果是：

```
{ 
    {2, 3, 6}, 
    {2, 3, 6}, 
    {2, 3, 6}
}
```



如果直接将两个矩阵使用 Pytorch 相乘，则是每个位置的数值相乘：

```csharp
var A = torch.tensor(new double[,]
{
    { 1.0, 2.0 }
});

var B = torch.tensor(new double[,]
{
    { 3.0, 4.0 }
});

// 或者 torch.mul(A, B)
(A * B).print_csharp();
```

```
[2x1], type = Float64, device = cpu, value = double [,] { {3}, {8}}
```





#### 矩阵乘法

**矩阵内积**

矩阵的内积和向量的内积一样，结果都是标量，等于两个矩阵的每个位置的乘法相加。例如以下矩阵的内积：
$$
\begin{bmatrix}
&1 &2 \\
&3 &4
\end{bmatrix} \cdot 
\begin{bmatrix}
&5 &6 \\
&7 &8
\end{bmatrix} = 1*5 + 2*6 + 3*7 + 4*8 = 70
$$
没有找到 Pytorch 中直接计算内积的方法。





**A ⊗ B **

这种外积方式使用频率不，每个位置等于 A 矩阵行和 B 矩阵列相乘之和。

比如下面是一个简单的 `2*2` 矩阵。


$$
\begin{bmatrix}
&a_{11} &a_{12} \\
&a_{21} &a_{22}
\end{bmatrix} \cdot 
\begin{bmatrix}
&b_{11} &b_{12} \\
&b_{21} &b_{22}
\end{bmatrix}
= 

\begin{bmatrix}
&c_{11} &c_{12} \\
&c_{21} &c_{22}
\end{bmatrix}
$$
因为 $c_{11}$ 是第一行第一列，所以 $c_{11}$ 是 A 矩阵的第一行乘以 B 第一列的和。
$$
c_{11} = a_{11}*b_{11}+a_{12}*b_{21}
$$
因为 $c_{12}$ 是第一行第二列，所以 $c_{12}$ 是 A 矩阵的第一行乘以 B 第二列的和。
$$
c_{12} = a_{11}*b_{12}+a_{12}*b_{22}
$$


因为 $c_{21}$ 是第二行第一列，所以 $c_{21}$ 是 A 矩阵的第二行乘以 B 第一列的和。
$$
c_{21} = a_{21}*b_{11}+a_{22}*b_{21}
$$
因为 $c_{22}$ 是第二行第二列，所以 $c_{22}$ 是 A 矩阵的第二行乘以 B 第二列的和。
$$
c_{22} = a_{21}*b_{12}+a_{22}*b_{22}
$$


实例如下：
$$
\begin{bmatrix}
&1 &2 \\
&3 &4
\end{bmatrix} \cdot 
\begin{bmatrix}
&5 &6 \\
&7 &8
\end{bmatrix}

= 

\begin{bmatrix}
&(1*5 + 2*7) &(1*6 + 2*8) \\
&(3*5 + 4*7) &(3*6 + 4*8)
\end{bmatrix}
=
\begin{bmatrix}
&19 &22 \\
&43 &50
\end{bmatrix}
$$


使用 C# 计算：

```csharp
var A = torch.tensor(new double[,]
{
    { 1.0, 2.0 },
    { 3.0, 4.0 }
});

var B = torch.tensor(new double[,]
{
     { 5.0 , 6.0 },
     { 7.0 , 8.0 }
});

torch.matmul(A, B).print_csharp();
```

```
{ {19, 22}, {43, 50}}
```



## 微积分

### 极限

极限的符号是 $\lim$ ，在高等数学中，主要是数列极限和函数极限，限于篇幅，本文只讨论函数存在极限时的一些情况。

数学上有无穷大($+\infty$)和无穷小($-\infty $)的概念，大家都知道无穷大的意思，但是比较容易理解错无穷小，**无穷小指的是无限接近 0，而不是负数的无穷大。**



举个例子你就明白了，当 $x \to +\infty$ 时，$\frac{1}{x} $ 的值，我们都知道 x 越大，，$\frac{1}{x} $ 越小，但是不可能为 0，只能越来越接近于 0，所以我们使用 $-\infty $ 表示这种情况。



求解极限，一般会碰到这几种情况，当 x 无穷大时，y 是多少。

例如下图所示，当 x 无穷大时，y 逐渐贴近 x 轴，即 y 越来越接近，我们使用 $y\to 0$ 表示趋近于 0 或者说接近 0。

![image-20241110092447001](images/image-20241110092447001.png)

> 图片来自《高等数学上册》第一章第三节函数极限的定义与计算，同济大学数学系编著。



所以：
$$
\lim_{x \to \infty} f(x) = \lim_{x \to \infty} \frac{1}{x} = 0
$$
使用 C# 表示时，我们使用一个极大的数表示无穷大。

```csharp
var x = torch.tensor(double.MaxValue);
var y = 1 / x;

var lim = (int)y.item<double>();
Console.WriteLine(lim);
```



上面使用了 `y.item<double>()` 将张量转换为标量，我们也可以使用函数 `y.ToScalar().ToInt32();` 转换。



再比如下图所示，当 x 无穷大时，y 越来越接近 $\frac{\pi}{2}$，所以 ：
$$
\lim_{x \to \infty} \arctan x = \frac{\pi}{2}
$$


![image-20241110092718306](images/image-20241110092718306.png)

> 图片来自《高等数学上册》第一章第三节函数极限的定义与计算，同济大学数学系编著。



上面求极限时，是当 $\lim_{x \to \infty} $ 或 $\lim_{x \to 0} $ 时的情况，在实际中更多的是给出某点，求其极限，例如：
$$
\lim_{x \to x_{0}} f(x) = \lim_{x \to x_{0}} \frac{1}{x}
$$


当 $x=1$ 时，我们直接计算其实可以得到 `y=1`，极限就是 1，或者换句话来说，我们求一个函数在 $x_{0}$ 的极限时，如果你可以直接计算出 $y_{0}$ 的值，那么这个值就是该点的极限。

这种函数计算极限很简单，因为可以直接通过 $y=f(x)$ 计算出来。



下面这道题是也是同济大学《高等数学上册》中的两道题。

![image-20241110095607086](images/image-20241110095607086.png)

当 x 解决 0 时，分子是 0，0 除以任何数都是 0，所以极限是 0？肯定不是呀。

当碰到这种 $x\to0$ 分子或分母为 0 的情况，就不能直接计算了。这两道题的解答过程：

![image-20241110095620201](images/image-20241110095620201.png)



由于本文不是数学教程，因此这里不再深入讨论细节。



### 导数

给定一个函数，如何计算函数在某个区间上的变化率？

如图所示，函数 $y = x^{2}$ 在区间 $[1,3]$ 的起点 A 和 终点 B。

![image-20241110102423654](images/image-20241110102423654.png)



那么平均变化率就是：
$$
\frac{\bigtriangleup y}{\bigtriangleup x} = \frac{9-1}{3-1} = \frac{8}{2} = 4
$$
但是当这个 $\bigtriangleup{x}$ 或 $\bigtriangleup{y}$ 非常小时，事情就会变得非常复杂。如果我们要求 $x=9$ 附近的平均变化率，则：
$$
\frac{y + \bigtriangleup y}{x+ \bigtriangleup x} = \frac{9 + \bigtriangleup y}{3 + \bigtriangleup x}
$$


当 $\frac{\bigtriangleup y}{\bigtriangleup x}$ 非常小时，实际上反映了函数在 $x=9$ 时的瞬时变化率。那么这个瞬时变化率，我们可以过 A、B 点使用切线表示。

切线是轻轻接触函数一点的一条线，由图可知，当 x 越来越大时，$y_{2} = x+1$ 比 $y_{1} = x$ 大很多，比如 $5^2$、$4^{2}$、$3^{2}$ 之间的差，越来越大。

那么切线可以反映这种变化率。如图所示，B 点的切线角度比 A 的的切线大。 

![image-20241110103552859](images/image-20241110103552859.png)



因此，出现了一种新的函数，叫原函数的导函数，简称导数，导数也是一个函数，通过导数可以计算原函数任一点的瞬时变化率。

导数的表示符号有多种，例如：
$$
\frac{\bigtriangleup y}{\bigtriangleup x} = f'(x) = y' = \frac{dy}{dx} = \frac{df(x)}{x}= \frac{df}{x}
$$

> d 是微分符号，例如 dy 是对 y 的微分，dx 是对 x 的微分。

如果要求在某点 $x_{0}$ 的瞬时变化率，则：
$$
\frac{\bigtriangleup y}{\bigtriangleup x} \big|_{x_{0}} = f'(x)  \big|_{x_{0}} = y'  \big|_{x_{0}} = \frac{dy}{dx}  \big|_{x_{0}} = \frac{df(x)}{x} \big|_{x_{0}} = \frac{df}{x} \big|_{x_{0}} 
$$




读者应该都有一定的数学基础吧，前面两种应该很容易理解，而后面三种也很重要，在积分和微积分的学习中，我们将会大量使用这种方式。

我们可以这样理解：
$$
dy = \bigtriangleup y
$$

$$
dx = \bigtriangleup x
$$



在 Pytorch 中，我们可以通过微分系统进行计算，例如我们要计算 $d(x^2) \big|_{x=3}$ 。

```csharp
// 定义 y = x^2 函数
var func = (torch.Tensor x) => x.pow(2);

var x = torch.tensor(3.0, requires_grad: true);
var y = func(x);

// 计算导数
y.backward();

// 转换为标量值
var grad = x.grad.ToScalar().ToDouble();
Console.WriteLine(grad);
```



不要搞错，计算导数后，要使用 x 输出导数值，而不是使用 y，因为 y 是函数结果。为什么求导的时候不直接输出求导结果呢？因为 Pytorch 自动求导系统是非常复杂的，计算的是偏导数，对于一元函数来说，对 x 的偏导数就是 y 的导数，在后面的偏导数和梯度时，会更多介绍这方面的知识。

另外创建 x 的张量类型时，需要添加 `requires_grad: true` 参数。



#### 求导公式

下面是同济大学《高等数学》中的一些基本求导公式。

![image-20241110105635460](images/image-20241110105635460.png)



例如，我们求 $y = x^2$ 的导数，使用上图的 （2）式，得到 $y = 2x$。





对于复合函数和复杂函数的求导会很麻烦，这里不再赘述。对于复杂的函数，还存在高阶导数，即导数的导数，二阶导数公式如下：
$$
f''(x) = y'' = \frac{d^2y}{dx^2} = \frac{d^2f(x)}{x^2}= \frac{d^2f}{x^2}
$$




### 微分



下面是同济大学《高等数学》中的一张图。

![image-20241110110700577](images/image-20241110110700577.png)



由图可知，在正方形 A 中，其面积是 $A = (x_{0})^2$，而大正方形的面积是 $(x_{0}+ \bigtriangleup x)^2$，或者通过多个矩形面积相加得出大正方形面积为：
$$
S = x_{0}^2 + 2x_{0} \bigtriangleup x + (\bigtriangleup x)^2
$$




那么，在边长增加了 $\bigtriangleup x$ 的时候，面积增加了多少呢？
$$
\bigtriangleup S = 2x_{0} \bigtriangleup x + (\bigtriangleup x)^2
$$


我们可以使用下面的公式来表示当 $y = f(x)$ 满足一定关系时，其增量的表达式：
$$
\bigtriangleup y = A \bigtriangleup x + O(\bigtriangleup x)
$$


前面在讲解导数时，我们知道 $\bigtriangleup y =f(x + \bigtriangleup x) - f(x)$，所以：
$$
\bigtriangleup y =f(x + \bigtriangleup x) - f(x) = A \bigtriangleup x + O(\bigtriangleup x)
$$




当 $\bigtriangleup x$ 非常小时，并且 $A \not= 0$ 时，可以忽略 $O(\bigtriangleup x)$，我们使用 $A \bigtriangleup x $ 近似计算 $\bigtriangleup y $ 的值，这就是微分的定义，其中 $A = f'(x)$。
$$
dy = f'(x)\bigtriangleup x
$$


举个例子，求 $y = x^3$ 在 $x=1$ 时， $\bigtriangleup x = 0.01$ 和 $\bigtriangleup x = 0.001$  的增量。

上题本质就是求 $x = 1.01$ 和 $x = 1$ 时  $\bigtriangleup y$  以及  $x = 1.001$ 和 $x = 1$ 时  $\bigtriangleup y$  。

先求：
$$
(1.01)^3 = 1.030301
$$

$$
(1.001)^3 = 1.003003001
$$

所以两个增量方便是 0.030301、0.003003001。



但是如果只需要求近似值，那么我们使用微分方式去求，首先求出导数：
$$
y' = dy = (x^3)' = 3x^2
$$
所以：
$$
dy = 3x^2 \bigtriangleup x
$$


所以 $\bigtriangleup x = 0.01$ 时，
$$
dy = 3*(1)^2 * 0.01 = 3 * 0.01 = 0.03
$$


所以 $\bigtriangleup x = 0.001$ 时，
$$
dy = 3*(1)^2 * 0.001 = 3 * 0.001 = 0.003
$$


所以可以这样通过微分 dy 的方式近似计算函数的增量。

因为：
$$
\bigtriangleup y = \frac{dy}{dx}
$$


我们使用 dy 近似代替 $\bigtriangleup y$，这就是微分的应用场景之一。



### 积分

前面介绍了导数，我们知道 $y = x^3$ 的导数是 $y = 3x^2$。

那么反过来，我们知道一个函数 $F(x)$ 的导数是 $y=x^3$，对于幂函数，我们很容易反推出 $\frac{1}{4} x^4$ 的导数是 $x^3$，但是  $\frac{1}{4} x^4 + 1$、 $\frac{1}{4} x^4 + 666$ 的导数都是 $x^3$ ，所以 $x^3$ 的原函数是不确定的，所以反推得出的积分公式，又叫不定积分，我们使用 $C$ 来表示这个不确定的常数。



假设原函数是 F(x)，导数是 $f(x)$ ，由于常数在求导时会被消去，所以求积分时，需要出现加上这个不确定的常数，所以：


$$
\int f(x)dx = F(x) + C
$$
下面是同济大学《高等数学》给出一些积分公式。

![image-20241110135308642](images/image-20241110135308642.png)



前面介绍了微分的作用，这里也给出导数在平面中的简单应用场景。



如图所示，图中的是 $y = x^2$ 函数的封闭区域，和 $x=0$ 、$x=2$ 两个直线围成了一个封闭区域，求 ABC 所围成的封闭区域的面积。

![image-20241110140743986](images/image-20241110140743986.png)

首先求出其原函数为 $y = \frac{1}{3}x^3$。使用积分区间表示求解的面积：
$$
\int_{1}^{2} x^2=\frac{1}{3}x^3 \big|_{1}^{2} =\frac{1}{3}2^3 - \frac{1}{3}1^3=\frac{7}{3}
$$


对于上面求解的问题，使用的是积分公式，如下公式所示，∫ 表示积分符号，$f(x)$ 表示被积函数，$dx$表示积分变量增量(微分)，$a$ 和 $b$ 表示积分的下限和上限，即积分区间。
$$
\int_{a}^{b} f(x) dx
$$


下面再来一道简单的题目，求 $y = 2x+3$ 和 $y = x^2$ 所围成的面积。

![image-20241110143455304](images/image-20241110143455304.png)



首先要求得积分区间，即两者的两个交点，由 $x^2=2x+3$ 得：
$$
x^2 - 2x -3 = 0
$$
根据十字相乘法，得：
$$
(x + 1)(x - 3) = 0
$$
所以 $x_{1} = -1$，$x_{2} = 3$。



我们先求 $y = 2x + 3$ 在这两个点之间围成的面积。
$$
\int_{-1}^{3} 2x+3 = x^2+3x \big|_{-1}^{3} = (9 + 9) - (1 - 3) = 20
$$
求 $y = x^2$ 在这两个点所围成的面积。
$$
\int_{-1}^{3} x^2 = \frac{1}{3}x^3 \big|_{-1}^{3} = 9 - (-\frac{1}{3}) = 9 + \frac{1}{3}
$$


所以围成的面积是：$20 - (9+\frac{1}{3}) = \frac{32}{3}$。



在数学上，我们可以更加方便表示这种两个函数加减的方法，即：
$$
\int_{-1}^{3} (2x+3 - x^2) = \int_{-1}^{3} (2x+3) - \int_{-1}^{3} (x^2)
$$

### 偏导数

偏导数属于多元函数的微分学，最常见的是求解空间问题，在初高中基本只涉及一元函数，在这里我们引入二元函数，记作：
$$
z = f(x,y)
$$

#### 多元函数

下面给出一个二元函数构成的图形。
$$
z=\sqrt{1-x^2-y^2}
$$
![image-20241110145138140](images/image-20241110145138140.png)

下面提个问题，怎么求这个$z=\sqrt{1-x^2-y^2}$ 的定义域？

我们知道 $1 \ge x^2 + y^2 $，在设 $y = 0$ 时，$1 \ge x^2 $，则 $-1 \le x \le 1$，由于 $1-x^2 \ge y^2$，所以 $-\sqrt{1-x^2} \le y \le \sqrt{1 - x^2}$。

关于二元函数的定义域，其实就是求 x、y 的定义域，我们可以求出 x 的定义域是常数组成，但是对于 y，就是由 x 组成的一个区间。



#### 多元函数的值

已知函数 $f(x,y) = \frac{xy}{x^2+y^2}$，求 $f(1,2)$。

其实也很简单，方便使用 $x=1,y=2$ 替代进去即可：
$$
f(1,2) = \frac{2}{1^2+2^2} = \frac{1}{5}
$$


#### 多元函数的极限

前面提到极限的时候，涉及到的都是一元函数，对于多元函数的极限，计算则复杂一些，我们可以使用以下公式表示二元函数在某点的极限值。
$$
\lim_{_{y \longrightarrow y_{0}}^{x \longrightarrow x_{0}}} f(x,y) = A
$$
求二元函数的极限，称为二重极限。

例如求下面函数的二重极限。
$$
\lim_{_{y \longrightarrow 2}^{x \longrightarrow 1}} \ln{(x+y^2)} = \ln{(1+2^2)} = \ln{5}
$$

#### 偏导数

对多元函数求导的时候，由于函数有多个未知变量，例如 $z = x^2 + y^2 $，要针对 x 进行求导，求在 $z=f(x_{0},y_{0})$ 时 x 的导数，这个就叫对 x 的偏导数。

偏导数使用符号 $\partial$ 表示，那么对 x 的偏导数可以记作：
$$
\frac{\partial z}{\partial x} \big|_{y=y_{0}}^{x=x{x0}}
$$
当然还有很多变体，Markdown 敲数学公式超级累，这里贴个图省事儿。

![image-20241110151831018](images/image-20241110151831018.png)



下面给个简单函数的偏导数，方法很简单，当对 x 求偏导数时，把 y 当常数处理即可。
$$
z = x^2 + y^2
$$

$$
\frac{\partial z}{\partial x} = 2x,\frac{\partial z}{\partial y} = 2y
$$

再如：
$$
z = x^2 + yx + y^2
$$

$$
\frac{\partial z}{\partial x} = 2x + y,\frac{\partial z}{\partial y} = 2y +x
$$



前面提到积分可以求解平面中两个函数所组成的封闭区域的面积，偏导数则可以计算空间中立体几何和平面组成的封闭区域面积，这里就不再深入。



#### 全微分

设二元函数 $z = f(x,y)$ 则其全增量公式为：
$$
\bigtriangleup z =A\bigtriangleup x + B \bigtriangleup y + O(\beta)
$$


那么关于 z 的微分：
$$
dz=f_{x}(x,y)dx + f_{y}(x,y)dy
$$
求全微分，其实就是先求出所有偏导数，然后再进行计算。

例如求 $z = e^{2x+3y}$ 的全微分。

![389b1a036ebf0d36c4c2233c49c3556](images/389b1a036ebf0d36c4c2233c49c3556.jpg)



给个例题，求函数 $z = f(x,y) = \frac{x^2}{y}$ 在 点 $(1,-2)$ 出，当 $\bigtriangleup x=0.02$，$\bigtriangleup y = -0.01$ 时的全增量。



先求函数的两个偏导数得出。
$$
dz = \frac{2x}{y} \bigtriangleup x - \frac{x^2}{y^2} \bigtriangleup y
$$
将 $\bigtriangleup x=0.02$，$\bigtriangleup y = -0.01$ 代入，得 $-0.0175$。



下面是这个函数的图像。

![image-20241110154210542](images/image-20241110154210542.png)





### 梯度

#### 方向导数

前面提到导数，在一元函数中，$y=f(x)$ ，导数是反映了其在某点的变化率，而在 $z = f(x,y)$ 中，两个偏导数 $\frac{\partial z}{\partial x} $、$\frac{\partial z}{\partial y}$ 则是反映函数沿着平行于 x 轴 、y 轴方向上的变化率。在实际问题中，我们除了要知道函数的变化率外，还要知道函数沿着哪个方向的变化率最大，这就需要引入方向导数的概念。



![image-20241110161833098](images/image-20241110161833098.png)

如上图所示，设 $l$ 是一条有 $P(x,y)$ 引出来的一条射线，$Q(x + \bigtriangleup x,y + \bigtriangleup y)$ 是 $l$ 上的一点，设 $\rho$ 是 $P$、$Q$ 两点之间的距离，则：
$$
\frac{\bigtriangleup z}{\rho}
$$
该公式反映函数在了 $P$、$Q$ 两点之间沿着 $l$ 方向的平均变化率，如果当 $Q$ 趋近于 $P$ 时，极限存在，则该极限值称为点 $P$ 沿方向 $l$ 的方向导数。



由于：
$$
\bigtriangleup x = \rho \cos \alpha , \bigtriangleup y = \rho \cos \beta
$$
所以方向导数可以表示为：
$$
\frac{\partial z}{\partial l} =  \frac{\partial z}{\partial x} \bigtriangleup x + \frac{\partial z}{\partial y} \bigtriangleup y =  \frac{\partial z}{\partial x} \cos \alpha + \frac{\partial z}{\partial y} \cos \beta
$$


#### 梯度

当点 $P$ 固定时，方向 $l$ 变化时，函数的方向导数 $\frac{\partial u}{\partial l} $ 也随之变化，说明了对于固定的点，函数在不同方向上的变化率也有所不同。那么对于点 $P$，在什么方向上可以使得函数的变化率达到最大？这里需要引入梯度的概念。

给定可微的二元函数 $z = f(x,y)$，在点 $(x_{0},y_{0})$ 可以确定一个向量 $e_{1}$：
$$
f_{x}(x_{0},y_{0})i + f_{y}(x_{0},y_{0})j
$$


称为函数 $z =f(x,y)$ 在点 $(x_{0},y_{0})$ 处的梯度，记作 $gradf(x_{0},y_{0})$。

方向导数和梯度的关系是：
$$
\frac{\partial z}{\partial l} = \frac{\partial z}{\partial x} \cos \alpha + \frac{\partial z}{\partial y} \cos \beta = 
gradf(x_{0},y_{0})\cdot e_{1}
$$


如下图所示，当 $\alpha = 0$ 时，$gradf(x_{0},y_{0})$ 和 $e_{1}$ 重合， 由于 $\cos \alpha = 1$，所以方向导数也达到最大值 $|gradf(x_{0},y_{0})|$ 。也就是，沿着梯度方向函数的方向导数可以达到最大值。



![image-20241110164906093](images/image-20241110164906093.png)





例题，求函数 $z = \ln(x^2 + y^2)$ 的梯度。

![image-20241110165653935](images/image-20241110165653935.png)

> 《高等数学工本》陈兆斗。

再来一道实际意义的题目。



![image-20241110170325278](images/image-20241110170325278.png)

> 《高等数学工本》陈兆斗。



使用 C# 求解该题，得：

```csharp
// 定义 u = x^2 + y^2 + z^2 函数在 (2,1,-1) 点的值
var x = torch.tensor(2.0, requires_grad: true);
var y = torch.tensor(1.0, requires_grad: true);
var z = torch.tensor(-1.0, requires_grad: true);
var u = x.pow(2) + y.pow(2) + z.pow(2);

// 求导
u.backward();

var ux = x.grad;
var uy = y.grad;
var uz = z.grad;

Console.WriteLine($"gradu(2,1,-1) = {"{"}{ux.ToScalar().ToDouble()},{uy.ToScalar().ToDouble()},{uz.ToScalar().ToDouble()} {"}"}");
```

```
gradu(2,1,-1) = {4,2,-2 }
```





## 概率论

因为笔者对概率论不熟，所以这里不写了。
